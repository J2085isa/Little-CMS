import asyncio
from claude_agent_sdk import query, ClaudeAgentOptions, ClaudeAgentError  # Asumiendo que el SDK define esta excepción

async def main():
    # Definir opciones con herramientas permitidas
    agent_options = ClaudeAgentOptions(
        allowed_tools=["Read", "Edit", "Bash"],
        # Se pueden agregar más opciones si el SDK las soporta (ej: timeout, nivel de detalle)
    )

    try:
        print("Enviando solicitud al agente Claude para revisar auth.py...\n")
        
        # Consumir la secuencia de mensajes asincrónicos
        async for message in query(
            prompt="Find and fix the bug in auth.py. Incluye un resumen de los cambios realizados.",
            options=agent_options
        ):
            # Diferenciar tipos de mensaje (ej: si el SDK incluye un campo 'type')
            if hasattr(message, "type"):
                print(f"[{message.type.upper()}] {message.content}\n")
            else:
                print(f"MENSAJE: {message}\n")

        print("Proceso completado exitosamente.")

    except ClaudeAgentError as e:
        print(f"Error del agente Claude: {str(e)}")
    except PermissionError:
        print("Error: No se tienen permisos suficientes para leer/editar auth.py o ejecutar comandos Bash.")
    except Exception as e:
        print(f"Error inesperado: {str(e)}")
    finally:
        print("\nFinalizando sesión con el agente.")

if __name__ == "__main__":
    asyncio.run(main())
import asyncio
from claude_agent_sdk import query, ClaudeAgentOptions, ClaudeAgentError  # Asumiendo que el SDK define esta excepción

async def main():
    # Definir opciones con herramientas permitidas
    agent_options = ClaudeAgentOptions(
        allowed_tools=["Read", "Edit", "Bash"],
        # Se pueden agregar más opciones si el SDK las soporta (ej: timeout, nivel de detalle)
    )

    try:
        print("Enviando solicitud al agente Claude para revisar auth.py...\n")
        
        # Consumir la secuencia de mensajes asincrónicos
        async for message in query(
            prompt="Find and fix the bug in auth.py. Incluye un resumen de los cambios realizados.",
            options=agent_options
        ):
            # Diferenciar tipos de mensaje (ej: si el SDK incluye un campo 'type')
            if hasattr(message, "type"):
                print(f"[{message.type.upper()}] {message.content}\n")
            else:
                print(f"MENSAJE: {message}\n")

        print("Proceso completado exitosamente.")

    except ClaudeAgentError as e:
        print(f"Error del agente Claude: {str(e)}")
    except PermissionError:
        print("Error: No se tienen permisos suficientes para leer/editar auth.py o ejecutar comandos Bash.")
    except Exception as e:
        print(f"Error inesperado: {str(e)}")
    finally:
        print("\nFinalizando sesión con el agente.")

if __name__ == "__main__":
    asyncio.run(main())
Ajustes adicionales importantes
 
- Se especifica el tipo del payload en los decoradores  @payload(...)  para que el compilador lo reconozca.
​
- Los datos per-primitive ( colorMask ) tienen un  @location  para que el fragment shader los pueda leer.
​
- Se usan sufijos  u  en todos los valores enteros sin signo para evitar ambigüedades de tipo.
​
- La estructura de salida de vértices incluye  @location  para el color, lo cual es necesario para pasar información al fragment shader.
 
Para que funcione en tu proyecto GitHub ("truk")
 
- Asegúrate de que los bindings de  positions  y  colors  coincidan con cómo creas los bind groups en tu código Rust/wgpu.
​
- Si tus posiciones son  vec3<f32> , conviértelas a  vec4<f32>  en el shader (ej:  vec4(positions[0], 1.0) ).
​
- Verifica que en tu pipeline de wgpu hayas habilitado la característica de mesh shaders y configurado correctamente los layouts de pipeline.
 
¿Necesitas que te ayude a adaptar el código Rust correspondiente para usar este shader en tu proyecto?
 Please see the documentation in doc folder
SISTEMA DE SEGURIDAD CUÁNTICA "Q-SECURE NET AUTOUPDATE"
 
Integración total con Q-Unify Core | API de automatización de actualización en red
 
 
 
1. ESTRUCTURA DEL MÓDULO
 
Incluido como subdirectorio en  q-unify-core/src/q-secure-net/ 
Componentes clave:
 
-  q_secure_net_api.py : API principal de seguridad y actualización cuántica
​
-  quantum_network_protocol.py : Protocolo de transmisión seguro en red
​
-  auto_update_manager.py : Gestor automatizado de actualizaciones
​
-  q_secure_config.toml : Archivo de configuración de red
​
-  drivers/ : Controladores para adaptación a diferentes redes
 
 
 
2. CÓDIGO FUENTE DEL SISTEMA DE SEGURIDAD
 
2.1 API PRINCIPAL ( q_secure_net_api.py )